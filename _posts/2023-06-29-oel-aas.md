---
layout:       post
title:        "Deploy IBM Open Enterprise Languages aaS with the SEAA framework"
author:       "Anthony Randolph"
header-img:   "img/in-post/post-oel-aas/bg-seaa_framework_automation.png"
catalog:      true
tags:
    - z/OS
    - Ansible
    - Automation
    - Open Source
---
<!-- > Bash on z/OS
![image](https://upload.wikimedia.org/wikipedia/commons/8/82/Gnu-bash-logo.svg) -->

> **Solution Recipe:** Deploy all [IBM Open Enterprise Languages](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=enhance-zos-applications-open-enterprise-languages) with one command: <br>  ```./run-deploy-oel-dev-env.sh --tags=oel-dev```


Welcome to the sweet solutions blog page, this is my first post and I am excited to blog about solutions that can help you in your modernization journey.
<!-- 
A little about me I am a software engineer with over 20 years experience at IBM. As such I've been fortunate enough to see many aspects of IBM's technology and solutions during my career. In my current role I am the lead for the Solutions Enablement team for IBM Z and Cloud Modernization Stack's. In addition to my love for technology I am a seasoned home cook and semi-professional baker and as such I am hoping to bring **'solution recipes'** to provide samples and technology to solve real problems. The solutions provided in my posts will engage and assist stakeholders in their day-to-day deployment of IBM Z and Cloud Modernization Stack and related technologies. -->

# Deploy Open Enterprise Languages-aaS
## _Ingredients_
   - [IBM Open Enterprise Languages](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=enhance-zos-applications-open-enterprise-languages)
   - [IBM Z and Cloud Modernization Stack](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack)
   - [IBM z/OS Package Manager]()
   - [IBM z/OS Cloud Broker]()
   - [IBM z/OS endpoint](https://www.ibm.com/products/zos)
   - [RedHat Ansible](https://www.ansible.com/)
   - [RedHat OpenShift](https://www.redhat.com/en/technologies/cloud-computing/openshift)
   - [Solution Enablement Ansible Automation (SEAA) framework](https://github.com/IBM/zmodstack-solutions/blob/main/docs/guide/README.md)

   <!-- https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=develop-zos-applications-wazi -->
## _Setting the Table_
IBM Z and Cloud Modernization Stack is a relatively new and exciting offering from IBM that provides multiple components that clients can use as a part of their modernization journeys on z/OS. The stack has components to assist with driving modernization patterns, as well as new application development on z/OS. See some of the key components of the stack below:

  - **[IBM Wazi](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=develop-zos-applications-wazi)** - a complete range of products that allow analysis, development, testing and DevOps on z/OS
    - **Wazi Analyze** - native cloud application used to analyze z/OS resources and source code usage patterns
    - **Wazi Code** - a set of modern development IDEs and technologies used to develop and test z/OS applications
    - **Wazi Deploy** - use DevOps to streamline z/OS application development
    - **Wazi Sandbox** - z/OS virtual machine for developing and testing z/OS application 
  - **[IBM z/OS Connect EE v3](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=access-z-assets-zos-connect)** - design open RESTFUL API's for z/OS assets and systems of record and deploy to containerized z/OS Connect EE operator
  - **[IBM z/OS Cloud Broker](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=automate-zos-resources-provisioning-zos-cloud-broker)** - allows developers to develop and deploy RedHat OpenShift operators and maintain state of resources and assets on z/OS endpoints

 In this blog I will dive into a specific use-case of z/OS Cloud Broker and how to use the SEAA framework to automate the deployment of IBM Open Enterprise Languages. The SEAA framework provides a prescriptive model based on [tags](https://github.com/IBM/zmodstack-solutions/blob/main/docs/guide/seaa-tags.md) and configuration [variables](https://github.com/IBM/zmodstack-solutions/blob/main/ibm/seaa/ansible/variables/README.md) provided. These values determine how the automation interacts with the underlying systems and a user. In the following sections I will outline specific steps that can be used to deploy the IBM Open Enterprise Languages using the SEAA framework.
### Planning target OpenShift and z/OS endpoint hosts
As a first planning step make note of the following information as it will be used later to create an Ansible [inventory](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html) file used by the SEAA framework to deploy resourced.<br/>

**Step 1:** Get OpenShift host information
- Get the API server for OpenShift host
  - From [Command line](https://github.com/IBM/zmodstack-solutions/blob/main/docs/howto/get-ocp-api-server.md)
  - <details>
    <summary>From OpenShift UI <i><strong> (click for video clip) </strong></i> </summary>
    <div class="video-container">
      <video controls autoplay loop muted style="width: 100%;">
      <source src="http://localhost:4000/sweet-solutions/img/in-post/post-oel-aas/ocpbout.mp4" type="video/mp4">
      </video>
    </div>
    </details> 
- Decide on login method to use:
  - [1Password Integration](https://github.com/IBM/zmodstack-solutions/blob/blog-seaa-post/docs/howto/integrate-with-1password-cli.md)
  - <details>
    <summary>OpenShift Auth Token <i><strong> (click for video clip) </strong></i> </summary>
    <p>If you use this method copy the token provided, it will be used as the `cluster_auth-token` in the inventory file</p>
    <div class="video-container">
      <video controls autoplay loop muted style="width: 100%;">
      <source src="http://localhost:4000/sweet-solutions/img/in-post/post-oel-aas/get_ocpauthtoken.mp4" type="video/mp4">
      </video>
    </div>
    </details> 
  <!-- - [OpenShift Auth Token](https://github.com/IBM/zmodstack-solutions/blob/blog-seaa-post/docs/howto/use-ocp-auth-token-in-inventory.md) -->
- If you are planning on using persistent volume storage when deploying IBM z/OS Cloud Broker (**recommend**) 
  -  Determine the `storage class` to use on OpenShift cluster, [volumeMode](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding-block-volumes) must be a `FileSystem`. See the [persistent volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) and [storage class](https://kubernetes.io/docs/concepts/storage/storage-classes/) documentation for more info. 
  -  The default storage class used by the SEAA framework is `rook-cephfs` and can be changed [here](https://github.com/IBM/zmodstack-solutions/blob/main/ibm/seaa/ansible/variables/defaults/ocp.yaml). 
  -  This can also be overridden per `ocphost` in the `inventory` file or by passing in `pvc_storage_class_name` as an Ansible [extra-vars](https://github.com/IBM/zmodstack-solutions/blob/main/ibm/seaa/ansible/variables/README.md#ansible-extra-vars).
  

**Step 2:** Get z/OS endpoint information
- Create or Select an existing z/OS Endpoint userid and SSH credentials that will be used to connect from OpenShift to the z/OS Endpoint, make sure userid has appropriate [authorization](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=planning-access-control-requirements-zos) on the z/OS Endpoint to install the desired languages: 
  - Userid for z/OS Endpoint with SSH public key deployed
  - SSH private key file for userid
  - Passphrase for userid (if required)  
- Allocated or select a directory that has at least 8G capacity for the ZPM Install and one that has 4G capacity for the ZPM state directory, see [storage](https://www.ibm.com/docs/en/cloud-paks/z-modernization-stack/2023.2?topic=planning-system-requirements#z-os-storage) requirements topic for more info: 
  - Default ZPM install directory: `/usr/lpp/IBM/zpm`
  - Default ZPM state directory: `/var/zpm`

## _Directions_
 Okay so as you can see I am a really taking this `solutions recipe` thing seriously, now that the table is set let's get the code and deploy some open enterprise languages ...
 
- **Step 0:** Get the Code
  - Clone the [zmodstack-solution](https://github.com/IBM/zmodstack-solutions) repo
  - [Setup](https://github.com/IBM/zmodstack-solutions/blob/main/docs/setup/get-started-workstation.md) workstation
  - [Configure](https://github.com/IBM/zmodstack-solutions/blob/main/docs/guide/configure-seaa.md) SEAA framework on your workstation

- **Step 1:** Create an inventory file
  - Copy [sample inventory file](https://github.com/IBM/zmodstack-solutions/blob/main/ibm/seaa/ansible/playbooks/inventory/sample-inventory.yaml)
  - Create a default `inventory.yaml` file in your `${SEAA_CONFIG_PATH_TO_SE_ANSIBLE_ARTIFACTS}/playbooks/inventory` directory and update it based on the values decided on from [above](http://localhost:4000/sweet-solutions/2023/06/29/oel-aas/#planning-target-openshift-and-zos-endpoint-hosts)
  - <details>
    <summary>Update inventory vars <i><strong> (click for video) </strong></i> </summary>
    <div class="video-container">
      <video controls autoplay loop muted style="width: 100%;">
      <source src="http://localhost:4000/sweet-solutions/img/in-post/post-oel-aas/ocpbout.mp4" type="video/mp4">
      </video>
    </div>
    </details>
   
<!--   
  - <details>
    <summary>Update inventory all vars <i><strong> (click for details) </strong></i> </summary>
    <div class="image-container">
    <img src="http://localhost:4000/sweet-solutions/img/in-post/post-oel-aas/seaa_inventory_charts_allvars.gif" alt="Your GIF"> 
    </div>
    </details>
  - <details>
    <summary>Update 'ocphosts' vars <i><strong> (click for details) </strong></i> </summary>
    <div class="image-container">
    <img src="http://localhost:4000/sweet-solutions/img/in-post/post-oel-aas/seaa_inventory_charts_ocphosts.gif" alt="Your GIF"> 
    </div>
    </details>
  - <details>
    <summary>Update 'zosendpoint' vars <i><strong> (click for details) </strong></i> </summary>
    <div class="image-container">
    <img src="http://localhost:4000/sweet-solutions/img/in-post/post-oel-aas/seaa_inventory_charts_zosendpoints.gif" alt="Your GIF"> 
    </div>
    </details>
   -->
<!-- ### Deploy OEL -->
- **Step 2** Run script to deploy IBM Open Enterprise Languages
  - By default the SEAA framework will deploy the [current GA](https://github.com/IBM/z-and-cloud-modernization-stack-community) version of the stack ... so no need to change any default variables if you want to deploy the current versions of IBM z/OS Cloud Broker, IBM Z/OS Package Manager and IBM Open Enterprise Languages.
  - Open the terminal to the run_scripts directory and run the following command: 
  - <details>
    <summary> <i>./run-deploy-oel-dev-env.sh --tags=oel-dev</i> <i><strong> (click for video) </strong></i> </summary>
    <div class="video-container">
      <video controls autoplay loop muted style="width: 100%;">
      <source src="http://localhost:4000/sweet-solutions/img/in-post/post-oel-aas/ocpabout.mp4" type="video/mp4">
      </video>
    </div>
    </details>

## _Wrap Up Next Steps_
Okay we made it to the end.. thanks for going thru my first post, at this point you should have the following deployed resources:
- On OpenShift
  - OpenShift Project
    - OpenShift Secrets for z/OS Endpoint user
    - IBM z/OS Cloud Broker
    - IBM z/OS Package Manager Operator
      - Customer resources for z/OS Products and Validations
- On z/OS endpoint
  - IBM z/OS Package Manager
    - IBM Open Enterprise Languages

Hopefully the steps outline here provided a good introduction to how using the SEAA framework can be used to deploy components ot the stack with a single command. This command could be added as apart of a CI/CD pipeline or you could even use the framework to 'generate' yaml files that can be deployed and managed in a SCM environment for multiple users. Keep an eye out for future solutions post or send me any suggested topics for consideration here - sweet-solutions@gmail.com:

Here are some potential topics ...
 - Generating YAML for deployment
 - Deploying OEL in OpenShift pipelines
 - Purging IBM Z and Cloud Modernization Stack resources 
 <!-- - Securing Development on WAZI Sandbox  -->
 <!-- - Develop OpenAPI on OpenShift with z/OS Cloud and Modernization Stack  -->

## Special Thanks
I would like to thank Mike Fulton for the motivation and wisdom to create ability to Deploy Open Enterprise Languages-aaS and Igor Todorovski for his assistance on getting this blog site up running.

<!-- 



As part of the [z/OS Open Tools](https://github.com/ZOSOpenTools) initiative, I, along with [Mike Fulton](https://makingdeveloperslivesbetter.wordpress.com), embarked on a journey to port Bash, the renowned shell and scripting language, to the z/OS platform. The motivation was simple: not having Bash on z/OS was a persistant pain point for me and others on z/OS. In this blog, I will discuss the technical challenges encountered while porting Bash to z/OS, and also discuss the steps taken to upstream the z/OS changes back to the Bash community.

But first, let's provide a bit of background on why we decided to port Bash:

# The Power of Bash on z/OS:
Bash, short for "Bourne-Again SHell," offers a slew of benefits over the default /bin/sh shell on z/OS. Here are some notable advantages that make Bash an indispensable tool for z/OS users:

* Tab completion: Bash's tab completion feature enhances productivity by allowing users to swiftly complete commands or filenames by typing a few characters followed by the Tab key. This reduces typing errors and accelerates command-line operations.

* Advanced scripting capabilities: Bash serves as a robust scripting language, allowing users to automate complex tasks. Leveraging variables, loops, conditions, and other programming constructs, Bash scripts enable complex automation scenarios.

* Compatibility with the Posix shell: Bash ensures seamless compatibility with the Posix bourne shell. This compatibility simplifies the transition process for z/OS users seeking to harness the power of Bash.

# Porting Bash to z/OS:
Contrary to my initial expectations, porting Bash to z/OS entailed fewer challenges than anticipated, thanks to the awesome efforts by various z/OS teams:

* [Clang compiler availability](https://www.ibm.com/docs/en/open-xl-c-cpp-zos/1.1?topic=new-llvm-clang-infrastructure) on z/OS
  * The latest Clang compiler on z/OS offers better compatibility with other platforms, both from a C and C++ standards perspective and also from an options compatilibity perspective. It also features an ASCII mode option, saving us the hassle of having to transform the open source code to be EBCDIC compatible.
* The [ZOSLIB library](https://github.com/ibmruntimes/zoslib)
  * The ZOSLIB library aims to bridge the gap between the z/OS C LE runtime and the Linux Glibc runtime, and also hides the complexities of dealing with files in different codepages. Remember, z/OS is primarily an EBCDIC system. In summary, ZOSLIB allows us to focus on the application specific issues.

## Notable challanges and resolutions
Although the porting of Bash to z/OS involved minimal changes, we encountered a few issues that required investigation and resolution.

### Supporting external link commands
z/OS includes several commands that serve as external links to z/OS dataset modules. Initially, Bash did not support this functionality. Consequently, when executing the following command in Bash on z/OS, we would get the following error message:

```bash
$ ping www.ibm.com
bash: ping: command not found
```
As seen here, netstat is an external link:
```
erwxrwxrwx   1 ROOT     1              8 Nov 11  2021 ping -> OPING
```
We addressed this issue in this [PR](https://github.com/ZOSOpenTools/bashport/pull/53)

```bash
$ ping www.ibm.com
CS V2R5: Pinging host www.ibm.com (104.70.245.61)
Ping #1 response took 0.018 seconds. (18.276 milliseconds)
```

### Fixing process substitution in z/OS
Another challenge we encountered was related to process substitution on z/OS. 
Process substitution is a useful feature that allows you to use the output of a command or a process as if it were a file. It provides a way to pass the output of a command as an input to another command or perform operations that require a file input.

Unfortuantely, this was broken in our initial port as seen here:

```bash
cat <(date)
(garbled output)
```

After applying the fix in [PR](https://github.com/ZOSOpenTools/bashport/pull/60/files), it worked:
```bash
cat <(date)
Fri May 24 11:34:28 CDT 2023
```

### Fixing the test cases
A significant portion of the effort was dedicated to resolving issues within the test cases. Fortunately, many tests failed due to a common reason: the error messages on z/OS included a prefix that differed from other platforms.

For example, on z/OS, an error message appeared as follows:

```bash
EDC5129I No such file or directory.
```

In contrast, on other platforms, the error message appeared without a prefix:

```bash
No such file or directory
```

Initially, we contemplated changing the expected ".right" files to accommodate the prefix differences. However, after engaging with the upstream maintainer, we made a collective decision to develop a "diff" wrapper that would eliminate the prefix codes specifically on z/OS.

# Contributing to the Bash Community:
Contributing the ported version of Bash back to the broader Bash community marked a significant milestone in this endeavor. The contribution process involved several key steps:

## Step 1: Community engagement: 
After some research, I identified the official Bash community, hosted on [Savannah](https://savannah.gnu.org/projects/bash/). I introduced myself and asked about the contribution guidelines and what the best way was to contribute these changes. I decided to use the Bash mailing list to introduce my intent to contribute the z/OS changes back. Here's my initial [email](https://lists.gnu.org/archive/html/bug-bash/2023-05/msg00048.html):
> Hi there,

> I’m looking for advice on the best way to submit a patch to enable support of 
z/OS.

> We have a few patches here which I will be cleaning up for the next few days: 
https://github.com/ZOSOpenTools/bashport/tree/main/patches

> Is it enough to just provide this patch location once they’re cleaned up? I 
confirmed that they apply to the master branch.

> Or is there a formal process for submitting patches?

> Also, on z/OS we have a prefix message id before the error text as in this 
case: 
https://github.com/ZOSOpenTools/bashport/blob/main/patches/PR3/builtins.right.patch

> Is there a preferred approach for how to handle this? Should I create a 
builtins.right.zos?

> Thanks,
Igor


## Step 2: Building the latest development branch of Bash on z/OS
The next step was to integrate and clean up our changes so that we could build the development branch of Bash on z/OS. This was done as part of [this PR](https://github.com/ZOSOpenTools/bashport/pull/62).

## Step 3: Seeking feedback on z/OS changes
After building the development branch of Bash on z/OS, I continued to engage with Chet Ramey, the maintainer of GNU Bash and provided a link to our working [github branch](https://github.com/ZOSOpenTools/bashport/tree/enable_git). He provided great feedback and was able to simplify and adapt many of my changes!

## Step 4: Iterative refinement
Guided by Chet's expert feedback, I refined the patches iteratively to align with the standards and best practices of the Bash community.

## Step 5: Success: The culmination of the upstreaming effort
The culmination of the upstreaming journey was reached when the patches were successfully integrated into the development branch of Bash:
![image](/blog/img/in-post/post-bash/patch1.png)
![image](/blog/img/in-post/post-bash/patch2.png)
Hooray!

# What's remaining?
* Although all of the source changes to enable Bash on z/OS have been upstreamed, the test case changes have yet to be upstreamed. I'm currently working with Chet on a solution that will not impact the other platforms. -->

